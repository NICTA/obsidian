//!
//! Contains global forward model evaluation functions
//!
//! \file fwdmodel/global.hpp
//! \author Lachlan McCalman
//! \date 2014
//! \license Affero General Public License version 3 or later
//! \copyright (c) 2014, NICTA
//!

#pragma once

#include "datatype/datatypes.hpp"
#include "world/interpolate.hpp"
#include "fwdmodel/fwd.hpp"

#include <glog/logging.h>

#include <future>

namespace obsidian
{
  namespace fwd
  {

    //! Generate a forward model cache object in a separate thread.
    //!
    //! \param boundaryInterpolation The world model interpolation parameters.
    //! \param spec The global world specifications.
    //! \param enabled Bool idicating if model is enabled. If not an empty cache is returned.
    //! \returns std::future containing the models cache object.
    //!
    template<ForwardModel f>
    std::future<typename Types<f>::Cache> generateCacheParallel(const std::vector<world::InterpolatorSpec>& interp,
                                                                const GlobalSpec& gSpec, bool enabled)
    {
      std::future<typename Types<f>::Cache> cache;
      if (enabled)
      {
        cache = std::async( std::launch::async, generateCache<f>, interp, gSpec.world,
                            globalSpec<GlobalSpec,typename Types<f>::Spec>(gSpec) );
      } else {
        cache = std::async( std::launch::deferred, [](){ return typename Types<f>::Cache(); } );
      }
      return cache;
    }

    //! Generate a global cache object for all forward models.
    //!
    //! \param boundaryInterpolation The world model interpolation parameters.
    //! \param spec The global world specifications.
    //! \returns Cache object containing the caches of all the forward models.
    //!
    GlobalCache generateGlobalCache(const std::vector<world::InterpolatorSpec>& interp, const GlobalSpec& spec,
                                    const std::set<ForwardModel>& enabled)
    {
      LOG(INFO) << "Generating Cache";

      // Some caches can take a while to generate, do it in parallel
      auto mag = generateCacheParallel<ForwardModel::MAGNETICS>(interp, spec, enabled.count(ForwardModel::MAGNETICS) );
      auto mtaniso = generateCacheParallel<ForwardModel::MTANISO>(interp, spec, enabled.count(ForwardModel::MTANISO) );
      auto seismic = generateCacheParallel<ForwardModel::SEISMIC1D>(interp, spec, enabled.count(ForwardModel::SEISMIC1D) );
      auto cpoint = generateCacheParallel<ForwardModel::CONTACTPOINT>(interp, spec, enabled.count(ForwardModel::CONTACTPOINT) );
      auto thermal = generateCacheParallel<ForwardModel::THERMAL>(interp, spec, enabled.count(ForwardModel::THERMAL) );
      return
      {
        enabled.count(ForwardModel::GRAVITY) ? generateCache<ForwardModel::GRAVITY>(interp, spec.world, spec.grav) : GravCache(),
        mag.get(), mtaniso.get(), seismic.get(), cpoint.get(), thermal.get()
      };
    }

    //! Run all the forward models.
    //!
    //! \param spec The global world specifications.
    //! \param cache The global forward model cache generated by generateCacheGlobal().
    //! \param params The global world parameters.
    //! \returns Results of all the forward models.
    //!
    GlobalResults forwardModelAll(const GlobalSpec& spec, const GlobalCache& cache, const GlobalParams& params,
                                  const std::set<ForwardModel>& enabled)
    {
      return
      {
        enabled.count(ForwardModel::GRAVITY) ? forwardModel<ForwardModel::GRAVITY>(spec.grav, cache.grav, params.world) : GravResults(),
        enabled.count(ForwardModel::MAGNETICS) ? forwardModel<ForwardModel::MAGNETICS>(spec.mag, cache.mag, params.world) : MagResults(),
        enabled.count(ForwardModel::MTANISO) ? forwardModel<ForwardModel::MTANISO>(spec.mt, cache.mt, params.world) : MtAnisoResults(),
        enabled.count(ForwardModel::SEISMIC1D) ? forwardModel<ForwardModel::SEISMIC1D>(spec.s1d, cache.s1d, params.world) : Seismic1dResults(),
        enabled.count(ForwardModel::CONTACTPOINT) ? forwardModel<ForwardModel::CONTACTPOINT>(spec.cpoint, cache.cpoint, params.world) : ContactPointResults(),
        enabled.count(ForwardModel::THERMAL) ? forwardModel<ForwardModel::THERMAL>(spec.therm, cache.therm, params.world) : ThermalResults(),
      };
    }
  }
}
