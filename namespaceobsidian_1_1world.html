<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Obsidian: obsidian::world Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Obsidian
   </div>
   <div id="projectbrief">Probabilistic Geophysical Joint Inversion</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceobsidian_1_1world.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">obsidian::world Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classobsidian_1_1world_1_1_interpolator_spec.html">InterpolatorSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a boundary of the layer, which is specified by a mesh grid of control points that vary in depth according to a vector of parameters.  <a href="classobsidian_1_1world_1_1_interpolator_spec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structobsidian_1_1world_1_1_query.html">Query</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aeb266dcd5a3a3d1cdd47f9cdf612e013"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#aeb266dcd5a3a3d1cdd47f9cdf612e013">SamplingStrategy</a> { <a class="el" href="namespaceobsidian_1_1world.html#aeb266dcd5a3a3d1cdd47f9cdf612e013a4fcf6366f30cb4cda6eda1e5143aaf5a">noAA</a>, 
<a class="el" href="namespaceobsidian_1_1world.html#aeb266dcd5a3a3d1cdd47f9cdf612e013a93af92f646fb70cf456efe8e72a405cd">superSamp2X</a>, 
<a class="el" href="namespaceobsidian_1_1world.html#aeb266dcd5a3a3d1cdd47f9cdf612e013a6ca472ed6f6f1399b2ab2163bd0a682f">superSamp4X</a>
 }</td></tr>
<tr class="memdesc:aeb266dcd5a3a3d1cdd47f9cdf612e013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a sampling strategy for queries.  <a href="namespaceobsidian_1_1world.html#aeb266dcd5a3a3d1cdd47f9cdf612e013">More...</a><br /></td></tr>
<tr class="separator:aeb266dcd5a3a3d1cdd47f9cdf612e013"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0b8c43fe70c6678fe996ca798e0afea7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b8c43fe70c6678fe996ca798e0afea7"></a>
Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>sensorGrid</b> (const <a class="el" href="classobsidian_1_1_world_spec.html">WorldSpec</a> &amp;worldSpec, uint resx, uint resy, double sensorZ)</td></tr>
<tr class="separator:a0b8c43fe70c6678fe996ca798e0afea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373a850bf691f162c3a8cf9b5ac20870"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a373a850bf691f162c3a8cf9b5ac20870"></a>
Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>internalGrid2D</b> (std::pair&lt; double, double &gt; xMinMax, std::pair&lt; double, double &gt; yMinMax, uint resx, uint resy)</td></tr>
<tr class="separator:a373a850bf691f162c3a8cf9b5ac20870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2296c624ef2368ff0929db3fee3768a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2296c624ef2368ff0929db3fee3768a1"></a>
Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>internalGrid2DX</b> (std::pair&lt; double, double &gt; xMinMax, std::pair&lt; double, double &gt; yMinMax, uint resx, uint resy)</td></tr>
<tr class="separator:a2296c624ef2368ff0929db3fee3768a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ff9300a10d0ef2b3f3b54316b3c9b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5ff9300a10d0ef2b3f3b54316b3c9b9"></a>
Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>edgeGrid2D</b> (std::pair&lt; double, double &gt; xMinMax, std::pair&lt; double, double &gt; yMinMax, uint resx, uint resy)</td></tr>
<tr class="separator:aa5ff9300a10d0ef2b3f3b54316b3c9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bc19e935e25e4372b67d91c98b11da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3bc19e935e25e4372b67d91c98b11da"></a>
Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>sensorGrid3d</b> (const <a class="el" href="classobsidian_1_1_world_spec.html">WorldSpec</a> &amp;worldSpec, uint resx, uint resy, uint resz)</td></tr>
<tr class="separator:ad3bc19e935e25e4372b67d91c98b11da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fcb2a0ba57eb4f4cf30b6982f27d3e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fcb2a0ba57eb4f4cf30b6982f27d3e0"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>length</b> (const Eigen::Vector2d &amp;pt)</td></tr>
<tr class="separator:a9fcb2a0ba57eb4f4cf30b6982f27d3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014bd2c09f6834178a9274f43299a263"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#a014bd2c09f6834178a9274f43299a263">linrange</a> (double from, double to, double step=1.0)</td></tr>
<tr class="memdesc:a014bd2c09f6834178a9274f43299a263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector containing regularly spaced numbers within a range. This is equivalent to the colon operator in MATLAB (Note the different parameter ordering).  <a href="#a014bd2c09f6834178a9274f43299a263">More...</a><br /></td></tr>
<tr class="separator:a014bd2c09f6834178a9274f43299a263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac007082f95c8d463ebcbb89388111c8c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac007082f95c8d463ebcbb89388111c8c"></a>
std::pair&lt; Eigen::MatrixXd, <br class="typebreak" />
Eigen::MatrixXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>meshgrid</b> (const Eigen::VectorXd &amp;x, const Eigen::VectorXd &amp;y)</td></tr>
<tr class="separator:ac007082f95c8d463ebcbb89388111c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f54515b3519d7c3855cb0664f9079cc"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#a1f54515b3519d7c3855cb0664f9079cc">flatten</a> (const Eigen::MatrixXd &amp;matrix)</td></tr>
<tr class="memdesc:a1f54515b3519d7c3855cb0664f9079cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps all the columns of a matrix into a single column vector. Equivalent to the colon operator A(:) in MATLAB.  <a href="#a1f54515b3519d7c3855cb0664f9079cc">More...</a><br /></td></tr>
<tr class="separator:a1f54515b3519d7c3855cb0664f9079cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb05cf6fd13d01fb936439d1e107650"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXi&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#a1fb05cf6fd13d01fb936439d1e107650">flatten</a> (const Eigen::MatrixXi &amp;matrix)</td></tr>
<tr class="memdesc:a1fb05cf6fd13d01fb936439d1e107650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps all the columns of a matrix into a single column vector. Equivalent to the colon operator A(:) in MATLAB.  <a href="#a1fb05cf6fd13d01fb936439d1e107650">More...</a><br /></td></tr>
<tr class="separator:a1fb05cf6fd13d01fb936439d1e107650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596f764973b94e81dbafb87ed5f9705a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; Eigen::MatrixXd, <br class="typebreak" />
std::pair&lt; Eigen::MatrixXd, <br class="typebreak" />
Eigen::MatrixXd &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#a596f764973b94e81dbafb87ed5f9705a">makeGrid</a> (const Eigen::Vector2d &amp;boundaryStart, const Eigen::Vector2d &amp;boundaryEnd, const Eigen::Vector2i &amp;resolution, int padding=0)</td></tr>
<tr class="memdesc:a596f764973b94e81dbafb87ed5f9705a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a regular 2D grid given the boundaries and resolutions in the x and y directions.  <a href="#a596f764973b94e81dbafb87ed5f9705a">More...</a><br /></td></tr>
<tr class="separator:a596f764973b94e81dbafb87ed5f9705a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac764b68716a49bb0e669062085fc0e4c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classobsidian_1_1world_1_1_interpolator_spec.html">InterpolatorSpec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#ac764b68716a49bb0e669062085fc0e4c">worldspec2Interp</a> (const <a class="el" href="classobsidian_1_1_world_spec.html">WorldSpec</a> &amp;region)</td></tr>
<tr class="memdesc:ac764b68716a49bb0e669062085fc0e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a vector of interpolators for each layer based on the key info contained in <a class="el" href="classobsidian_1_1_world_spec.html">WorldSpec</a>.  <a href="#ac764b68716a49bb0e669062085fc0e4c">More...</a><br /></td></tr>
<tr class="separator:ac764b68716a49bb0e669062085fc0e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496637f531aefcf0c4d5c4bb749ec7fe"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#a496637f531aefcf0c4d5c4bb749ec7fe">kernelInterpolate</a> (const <a class="el" href="structobsidian_1_1world_1_1_query.html">Query</a> &amp;query, const uint boundary, const Eigen::MatrixXd &amp;input)</td></tr>
<tr class="memdesc:a496637f531aefcf0c4d5c4bb749ec7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a 3D query, interpolate the depth of each point in the query.  <a href="#a496637f531aefcf0c4d5c4bb749ec7fe">More...</a><br /></td></tr>
<tr class="separator:a496637f531aefcf0c4d5c4bb749ec7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9dc99a700e9cc12b8eb1abcbdae7b1"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#a9f9dc99a700e9cc12b8eb1abcbdae7b1">linearInterpolate</a> (const <a class="el" href="structobsidian_1_1world_1_1_query.html">Query</a> &amp;query, <a class="el" href="classobsidian_1_1world_1_1_interpolator_spec.html">InterpolatorSpec</a> interpolator)</td></tr>
<tr class="memdesc:a9f9dc99a700e9cc12b8eb1abcbdae7b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a 3D query, interpolate the depth of each point in the query linearly.  <a href="#a9f9dc99a700e9cc12b8eb1abcbdae7b1">More...</a><br /></td></tr>
<tr class="separator:a9f9dc99a700e9cc12b8eb1abcbdae7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23812dca31cc9d53229db8da123d602a"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#a23812dca31cc9d53229db8da123d602a">sqExp</a> (const Eigen::MatrixXd &amp;x1, const Eigen::MatrixXd &amp;x2, const Eigen::VectorXd &amp;lengthScale, bool noisy=false)</td></tr>
<tr class="memdesc:a23812dca31cc9d53229db8da123d602a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a covariance matrix using the square exponential function.  <a href="#a23812dca31cc9d53229db8da123d602a">More...</a><br /></td></tr>
<tr class="separator:a23812dca31cc9d53229db8da123d602a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253b1b7ff61da60e49e69fe034200388"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#a253b1b7ff61da60e49e69fe034200388">sqExp2d</a> (const Eigen::Matrix&lt; double, 2,-1 &gt; &amp;x1, const Eigen::Matrix&lt; double, 2,-1 &gt; &amp;x2, const Eigen::Vector2d &amp;lengthScale, bool noisy=false)</td></tr>
<tr class="memdesc:a253b1b7ff61da60e49e69fe034200388"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a covariance matrix using the squared exponential function. This function is faster than sqExp, but only applies when the dimensions of the points is 2 (which is true for control points and query points).  <a href="#a253b1b7ff61da60e49e69fe034200388">More...</a><br /></td></tr>
<tr class="separator:a253b1b7ff61da60e49e69fe034200388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12618bb01c6f6f667fcd5588c7286de5"><td class="memItemLeft" align="right" valign="top">Eigen::Vector2d&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#a12618bb01c6f6f667fcd5588c7286de5">autoLengthScale</a> (const std::pair&lt; double, double &gt; &amp;x1x2, const std::pair&lt; double, double &gt; &amp;y1y2, uint resx, uint resy)</td></tr>
<tr class="memdesc:a12618bb01c6f6f667fcd5588c7286de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an appropriate length scale given the grid resolution and a smoothing factor.  <a href="#a12618bb01c6f6f667fcd5588c7286de5">More...</a><br /></td></tr>
<tr class="separator:a12618bb01c6f6f667fcd5588c7286de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5142dd6156325c95786f68d71d9693c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#ad5142dd6156325c95786f68d71d9693c">boundDensity</a> (double raw)</td></tr>
<tr class="memdesc:ad5142dd6156325c95786f68d71d9693c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound the density property.  <a href="#ad5142dd6156325c95786f68d71d9693c">More...</a><br /></td></tr>
<tr class="separator:ad5142dd6156325c95786f68d71d9693c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf439fe9e9f1a00b3089c6f674bbcd72"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#adf439fe9e9f1a00b3089c6f674bbcd72">boundLogSusceptibility</a> (double raw)</td></tr>
<tr class="memdesc:adf439fe9e9f1a00b3089c6f674bbcd72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound the log susceptibility.  <a href="#adf439fe9e9f1a00b3089c6f674bbcd72">More...</a><br /></td></tr>
<tr class="separator:adf439fe9e9f1a00b3089c6f674bbcd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1112c84b17dd379421e4da2e5a56721"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#ad1112c84b17dd379421e4da2e5a56721">boundThermalConductivity</a> (double raw)</td></tr>
<tr class="memdesc:ad1112c84b17dd379421e4da2e5a56721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound the thermal conductivity.  <a href="#ad1112c84b17dd379421e4da2e5a56721">More...</a><br /></td></tr>
<tr class="separator:ad1112c84b17dd379421e4da2e5a56721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad834cb8c6dc02818f08ccf73af1fcc16"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#ad834cb8c6dc02818f08ccf73af1fcc16">boundThermalProductivity</a> (double raw)</td></tr>
<tr class="memdesc:ad834cb8c6dc02818f08ccf73af1fcc16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound the thermal productivity.  <a href="#ad834cb8c6dc02818f08ccf73af1fcc16">More...</a><br /></td></tr>
<tr class="separator:ad834cb8c6dc02818f08ccf73af1fcc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66bb2606c438a9e036f0e0b05ba26976"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#a66bb2606c438a9e036f0e0b05ba26976">boundLogResistivity</a> (double raw)</td></tr>
<tr class="memdesc:a66bb2606c438a9e036f0e0b05ba26976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound the log resistivity.  <a href="#a66bb2606c438a9e036f0e0b05ba26976">More...</a><br /></td></tr>
<tr class="separator:a66bb2606c438a9e036f0e0b05ba26976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45df821f580073e9985de54952568d18"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#a45df821f580073e9985de54952568d18">boundResistivity</a> (double raw)</td></tr>
<tr class="memdesc:a45df821f580073e9985de54952568d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound the resistivity.  <a href="#a45df821f580073e9985de54952568d18">More...</a><br /></td></tr>
<tr class="separator:a45df821f580073e9985de54952568d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac445def40d525032f031e9ffab60eb1a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#ac445def40d525032f031e9ffab60eb1a">boundResistivityPhase</a> (double raw)</td></tr>
<tr class="memdesc:ac445def40d525032f031e9ffab60eb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound the resistivity phase.  <a href="#ac445def40d525032f031e9ffab60eb1a">More...</a><br /></td></tr>
<tr class="separator:ac445def40d525032f031e9ffab60eb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c797d420950370b3d28dcddf20e6b9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#ab5c797d420950370b3d28dcddf20e6b9">boundPWaveVelocity</a> (double raw)</td></tr>
<tr class="memdesc:ab5c797d420950370b3d28dcddf20e6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound the primary wave velocity.  <a href="#ab5c797d420950370b3d28dcddf20e6b9">More...</a><br /></td></tr>
<tr class="separator:ab5c797d420950370b3d28dcddf20e6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa597a6db8273af1fa650bb9f6b029aa5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#aa597a6db8273af1fa650bb9f6b029aa5">boundSusceptibility</a> (double raw)</td></tr>
<tr class="memdesc:aa597a6db8273af1fa650bb9f6b029aa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound the susceptibility.  <a href="#aa597a6db8273af1fa650bb9f6b029aa5">More...</a><br /></td></tr>
<tr class="separator:aa597a6db8273af1fa650bb9f6b029aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef88e7a4fe83555667e529b3469c680"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#afef88e7a4fe83555667e529b3469c680">extractProperty</a> (const <a class="el" href="structobsidian_1_1_world_params.html">WorldParams</a> &amp;input, obsidian::RockProperty desiredProp)</td></tr>
<tr class="memdesc:afef88e7a4fe83555667e529b3469c680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a particular property from the <a class="el" href="structobsidian_1_1_world_params.html" title="These are optimised. ">WorldParams</a>.  <a href="#afef88e7a4fe83555667e529b3469c680">More...</a><br /></td></tr>
<tr class="separator:afef88e7a4fe83555667e529b3469c680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70137625956ce1a8827ca1033d53dc9"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#aa70137625956ce1a8827ca1033d53dc9">getTransitions</a> (const std::vector&lt; <a class="el" href="classobsidian_1_1world_1_1_interpolator_spec.html">world::InterpolatorSpec</a> &gt; &amp;boundaries, const <a class="el" href="structobsidian_1_1_world_params.html">WorldParams</a> &amp;inputs, const <a class="el" href="structobsidian_1_1world_1_1_query.html">Query</a> &amp;query)</td></tr>
<tr class="memdesc:aa70137625956ce1a8827ca1033d53dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the depths of each layer at each query point.  <a href="#aa70137625956ce1a8827ca1033d53dc9">More...</a><br /></td></tr>
<tr class="separator:aa70137625956ce1a8827ca1033d53dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4032a783c342c2c7c412de8fa329e266"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#a4032a783c342c2c7c412de8fa329e266">thickness</a> (const Eigen::MatrixXd &amp;transitions)</td></tr>
<tr class="memdesc:a4032a783c342c2c7c412de8fa329e266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the thickness of each layer at each query point.  <a href="#a4032a783c342c2c7c412de8fa329e266">More...</a><br /></td></tr>
<tr class="separator:a4032a783c342c2c7c412de8fa329e266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc262553171add430931025e30cc28da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc262553171add430931025e30cc28da"></a>
Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#afc262553171add430931025e30cc28da">postProcessGranites</a> (const Eigen::MatrixXd &amp;transitioni, Eigen::VectorXd offseti, const Eigen::MatrixXd &amp;transitionj, const <a class="el" href="structobsidian_1_1world_1_1_query.html">Query</a> &amp;query, const uint region, const Eigen::MatrixXd &amp;inputs, double floorHeight)</td></tr>
<tr class="memdesc:afc262553171add430931025e30cc28da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code for post-processing the granites, applying a non-linear transform to their heights. <br /></td></tr>
<tr class="separator:afc262553171add430931025e30cc28da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f72a9fae1648c85fa460b4fd0613a75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f72a9fae1648c85fa460b4fd0613a75"></a>
Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>getVoxels</b> (const std::vector&lt; <a class="el" href="classobsidian_1_1world_1_1_interpolator_spec.html">world::InterpolatorSpec</a> &gt; &amp;interpolators, const <a class="el" href="structobsidian_1_1_world_params.html">WorldParams</a> &amp;inputs, const <a class="el" href="structobsidian_1_1world_1_1_query.html">Query</a> &amp;query, obsidian::RockProperty desiredProp)</td></tr>
<tr class="separator:a5f72a9fae1648c85fa460b4fd0613a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bba3b4206146065291af47b5a43b42a"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceobsidian_1_1world.html#a2bba3b4206146065291af47b5a43b42a">voxelise</a> (const Eigen::MatrixXd &amp;transitions, const Eigen::VectorXd &amp;zIntercepts, const Eigen::VectorXd &amp;props)</td></tr>
<tr class="memdesc:a2bba3b4206146065291af47b5a43b42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert transitions into a grid of points.  <a href="#a2bba3b4206146065291af47b5a43b42a">More...</a><br /></td></tr>
<tr class="separator:a2bba3b4206146065291af47b5a43b42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72cb131afe6aab7d040967bf95bb8eaa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72cb131afe6aab7d040967bf95bb8eaa"></a>
Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><b>shrink3d</b> (const Eigen::VectorXd &amp;densities, int nx, int ny, int nz)</td></tr>
<tr class="separator:a72cb131afe6aab7d040967bf95bb8eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for world model related functionality. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="aeb266dcd5a3a3d1cdd47f9cdf612e013"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceobsidian_1_1world.html#aeb266dcd5a3a3d1cdd47f9cdf612e013">obsidian::world::SamplingStrategy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a sampling strategy for queries. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aeb266dcd5a3a3d1cdd47f9cdf612e013a4fcf6366f30cb4cda6eda1e5143aaf5a"></a>noAA&#160;</td><td class="fielddoc">
<p>Sample with no anti-aliasing. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aeb266dcd5a3a3d1cdd47f9cdf612e013a93af92f646fb70cf456efe8e72a405cd"></a>superSamp2X&#160;</td><td class="fielddoc">
<p>Supersample at twice the resolution. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aeb266dcd5a3a3d1cdd47f9cdf612e013a6ca472ed6f6f1399b2ab2163bd0a682f"></a>superSamp4X&#160;</td><td class="fielddoc">
<p>Supersample at four times the resolution. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a12618bb01c6f6f667fcd5588c7286de5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Vector2d obsidian::world::autoLengthScale </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; double, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; double, double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y1y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>resx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>resy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an appropriate length scale given the grid resolution and a smoothing factor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1x2</td><td>The start and end of the grid boundaries in the x direction. </td></tr>
    <tr><td class="paramname">y1y2</td><td>The start and end of the grid boundaries in the y direction. </td></tr>
    <tr><td class="paramname">resx</td><td>The resolution of the grid in the x direction. </td></tr>
    <tr><td class="paramname">resy</td><td>The resolution of the grid in the y direction. </td></tr>
    <tr><td class="paramname">smoothing</td><td>The smoothing factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A two dimensional vector containing the length scales for the x and y dimensions. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5142dd6156325c95786f68d71d9693c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double obsidian::world::boundDensity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bound the density property. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>The raw density value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bounded density value. </dd></dl>

</div>
</div>
<a class="anchor" id="a66bb2606c438a9e036f0e0b05ba26976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double obsidian::world::boundLogResistivity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bound the log resistivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>The raw log resistivity value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bounded log resistivity value. </dd></dl>

</div>
</div>
<a class="anchor" id="adf439fe9e9f1a00b3089c6f674bbcd72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double obsidian::world::boundLogSusceptibility </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bound the log susceptibility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>The raw log susceptibility value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bounded log susceptibility value. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5c797d420950370b3d28dcddf20e6b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double obsidian::world::boundPWaveVelocity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bound the primary wave velocity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>The raw primary wave velocity value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bounded primary wave velocity value. </dd></dl>

</div>
</div>
<a class="anchor" id="a45df821f580073e9985de54952568d18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double obsidian::world::boundResistivity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bound the resistivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>The raw resistivity value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bounded resistivity value. </dd></dl>

</div>
</div>
<a class="anchor" id="ac445def40d525032f031e9ffab60eb1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double obsidian::world::boundResistivityPhase </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bound the resistivity phase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>The raw resistivity phase value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bounded resistivity phase value. </dd></dl>

</div>
</div>
<a class="anchor" id="aa597a6db8273af1fa650bb9f6b029aa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double obsidian::world::boundSusceptibility </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bound the susceptibility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>The raw susceptibility value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bounded susceptibility value. </dd></dl>

</div>
</div>
<a class="anchor" id="ad1112c84b17dd379421e4da2e5a56721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double obsidian::world::boundThermalConductivity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bound the thermal conductivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>The raw thermal conductivity value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bounded thermal conductivity value. </dd></dl>

</div>
</div>
<a class="anchor" id="ad834cb8c6dc02818f08ccf73af1fcc16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double obsidian::world::boundThermalProductivity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bound the thermal productivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">raw</td><td>The raw thermal productivity value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bounded thermal productivity value. </dd></dl>

</div>
</div>
<a class="anchor" id="afef88e7a4fe83555667e529b3469c680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd obsidian::world::extractProperty </td>
          <td>(</td>
          <td class="paramtype">const WorldParams &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">obsidian::RockProperty&#160;</td>
          <td class="paramname"><em>desiredProp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a particular property from the <a class="el" href="structobsidian_1_1_world_params.html" title="These are optimised. ">WorldParams</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>the worldParams object. </td></tr>
    <tr><td class="paramname">desiredProp</td><td>the desired property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of that property for each layer in the world. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f54515b3519d7c3855cb0664f9079cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd obsidian::world::flatten </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps all the columns of a matrix into a single column vector. Equivalent to the colon operator A(:) in MATLAB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to flatten. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A column vector containing the flattened matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a1fb05cf6fd13d01fb936439d1e107650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXi obsidian::world::flatten </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps all the columns of a matrix into a single column vector. Equivalent to the colon operator A(:) in MATLAB. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to flatten. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A column vector containing the flattened matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="aa70137625956ce1a8827ca1033d53dc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd obsidian::world::getTransitions </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; world::InterpolatorSpec &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WorldParams &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Query &amp;&#160;</td>
          <td class="paramname"><em>query</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the depths of each layer at each query point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundaries</td><td>The interpolator specs for each layer. </td></tr>
    <tr><td class="paramname">inputs</td><td>The world model parameters. </td></tr>
    <tr><td class="paramname">query</td><td>The query containing the query points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix with rows containing the depths of the query points at every layer. </dd></dl>

</div>
</div>
<a class="anchor" id="a496637f531aefcf0c4d5c4bb749ec7fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd obsidian::world::kernelInterpolate </td>
          <td>(</td>
          <td class="paramtype">const Query &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a 3D query, interpolate the depth of each point in the query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>The 3D query. </td></tr>
    <tr><td class="paramname">layer</td><td>The layer to interpolate in. </td></tr>
    <tr><td class="paramname">input</td><td>The packed parameter values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of depths that correspond to each query point. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f9dc99a700e9cc12b8eb1abcbdae7b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd obsidian::world::linearInterpolate </td>
          <td>(</td>
          <td class="paramtype">const Query &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterpolatorSpec&#160;</td>
          <td class="paramname"><em>interpolator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a 3D query, interpolate the depth of each point in the query linearly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>The 3D query. </td></tr>
    <tr><td class="paramname">interpolator</td><td>The interpolator specificaitons.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of depths that correspond to each query point. </dd></dl>

</div>
</div>
<a class="anchor" id="a014bd2c09f6834178a9274f43299a263"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::VectorXd obsidian::world::linrange </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>step</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a vector containing regularly spaced numbers within a range. This is equivalent to the colon operator in MATLAB (Note the different parameter ordering). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The start of the range. </td></tr>
    <tr><td class="paramname">to</td><td>The end of the range (inclusive). </td></tr>
    <tr><td class="paramname">step</td><td>The step size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a596f764973b94e81dbafb87ed5f9705a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Eigen::MatrixXd, std::pair&lt; Eigen::MatrixXd, Eigen::MatrixXd &gt; &gt; obsidian::world::makeGrid </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Vector2d &amp;&#160;</td>
          <td class="paramname"><em>boundaryStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector2d &amp;&#160;</td>
          <td class="paramname"><em>boundaryEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector2i &amp;&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>padding</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a regular 2D grid given the boundaries and resolutions in the x and y directions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundaryStart,boundaryEnd</td><td>The start and end boundaries. </td></tr>
    <tr><td class="paramname">resolution</td><td>The resolution in each direction (npoints in each direction). </td></tr>
    <tr><td class="paramname">padding</td><td>Number of cells to extend outside the boundaries. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a23812dca31cc9d53229db8da123d602a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd obsidian::world::sqExp </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>lengthScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noisy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a covariance matrix using the square exponential function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1,x2</td><td>DxN matrices. Each row represents the input in one dimension. </td></tr>
    <tr><td class="paramname">lengthScale</td><td>Vector containing length scale value for each dimension. </td></tr>
    <tr><td class="paramname">noisy</td><td>Whether noise is modelled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a253b1b7ff61da60e49e69fe034200388"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd obsidian::world::sqExp2d </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 2,-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; double, 2,-1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Vector2d &amp;&#160;</td>
          <td class="paramname"><em>lengthScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noisy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a covariance matrix using the squared exponential function. This function is faster than sqExp, but only applies when the dimensions of the points is 2 (which is true for control points and query points). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1,x2</td><td>2xN matrices. Each row represents the input in one dimension. </td></tr>
    <tr><td class="paramname">lengthScale</td><td>Vector containing length scale value for each dimension. </td></tr>
    <tr><td class="paramname">noisy</td><td>Whether noise is modelled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4032a783c342c2c7c412de8fa329e266"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd obsidian::world::thickness </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>transitions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the thickness of each layer at each query point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transitions</td><td>A nlayers by mqueries matrix of the transitions between layers at each sensor location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An mqueries x nthicknesses matrix of layer thicknesses at each sensor location. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bba3b4206146065291af47b5a43b42a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd obsidian::world::voxelise </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>transitions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>zIntercepts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert transitions into a grid of points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transitions</td><td>The layer transitions. </td></tr>
    <tr><td class="paramname">zIntercepts</td><td>A vector containing the z coordinates of the voxels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A matrix of property values. Rows contain the property values of each transition point at every depth specified by zIntercepts. The property values are obtained from linear interpolation. </dd></dl>

</div>
</div>
<a class="anchor" id="ac764b68716a49bb0e669062085fc0e4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classobsidian_1_1world_1_1_interpolator_spec.html">InterpolatorSpec</a> &gt; obsidian::world::worldspec2Interp </td>
          <td>(</td>
          <td class="paramtype">const WorldSpec &amp;&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a vector of interpolators for each layer based on the key info contained in <a class="el" href="classobsidian_1_1_world_spec.html">WorldSpec</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">region</td><td>The world specifications. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceobsidian.html">obsidian</a></li><li class="navelem"><a class="el" href="namespaceobsidian_1_1world.html">world</a></li>
    <li class="footer">Generated on Mon Jun 30 2014 12:14:33 for Obsidian by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
