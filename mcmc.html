<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Obsidian: Markov Chain Monte Carlo</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Obsidian
   </div>
   <div id="projectbrief">Probabilistic Geophysical Joint Inversion</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('mcmc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Markov Chain Monte Carlo </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Obsidian uses <a href="http://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo">Markov Chain Monte Carlo methods</a> to sample from the probability distribution defined by the <a class="el" href="world.html">world model</a>. All code related to MCMC are in a separate namespace <code>stateline</code>.</p>
<h2>The Algorithm </h2>
<p>Obsidian implements a <a href="http://en.wikipedia.org/wiki/Parallel_tempering">tempered</a> random-walk Metropolis-Hastings Markov Chain sampler. However, because the likelihood function in an inversion problem is expensive to evaluate (need to simulate sensor forward models), we delegate the task of evaluating MCMC states to the workers (implemented in the <code>shard</code> tool). This allows Obsidian to evaluate many MCMC states in parallel by submitting state evaluation jobs to a cluster of workers simultaneously, and retrieving the results one by one.</p>
<h2>Asynchronous Policy </h2>
<p>A key concept of the Obsidian MCMC module is an <em>asynchronous policy</em> (async policy for short), which dictates how states can be evaluated asynchronously (out of order). As mentioned in the previous section, to take advantage of the worker cluster, the MCMC sampler must be able to send jobs in batch to the workers, and retrieve them back one by one. So any class implementing the asynchronous policy interface must have the following method signatures:</p>
<div class="fragment"><div class="line"><span class="comment">// Submit a job with an identifier &#39;id&#39; to evaluate the state &#39;theta&#39;</span></div>
<div class="line"><span class="keywordtype">void</span> submit(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> Eigen::VectorXd &amp;theta);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Retrieve the next finished job result. Returns a pair, where the first</span></div>
<div class="line"><span class="comment">// element is the ID of the job and the second element is the log likelihood.</span></div>
<div class="line">std::pair&lt;unsigned int, double&gt; retrieve();</div>
</div><!-- fragment --><p>For an example of an async policy, see <a class="el" href="classobsidian_1_1_geo_async_policy.html">GeoAsyncPolicy</a>, which is used in the geophysical inversion. Note that this async policy also performs <em>multiplexing</em>, which splits up the job it receives in <code>submit()</code> into several smaller sub-tasks, one for each sensor type. It then recombines the results of these sub-tasks together to compute a joint likelihood in <code>retrieve()</code>.</p>
<h2>The Sampler Class </h2>
<p>The main interface for running MCMC simulations is the <a class="el" href="classstateline_1_1mcmc_1_1_sampler.html">Sampler</a> class. The overall process of the MCMC simulation is briefly outlined below:</p>
<ol type="1">
<li>Initialise all the chains according to initial conditions specified in the settings.</li>
<li>Perform some pre-processing annealing steps to start the chains with reasonable initial states.</li>
<li>Submit an initial proposal for each chain through the async policy.</li>
<li>While the time limit has not been reached:<ol type="a">
<li>Retrieve an evaluation result from the async policy.</li>
<li>Determine whether to accept or reject the proposal (based on the <a href="http://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm">Metropolis Criterion</a>).</li>
<li>Determine whether to swap with another chain (for tempering).</li>
<li>Adapt the proposal width to meet optimal acceptance rate.</li>
<li>Adapt the temperature to meet optimal swap rate.</li>
<li>Update convergence statistics.</li>
<li>Submit a new proposal through the async policy.</li>
</ol>
</li>
</ol>
<p>Note that the networking aspects involved in distributing tasks to workers is completely abstracted away by the async policy.</p>
<h2>ChainArray and the Disk Database </h2>
<p>The storage of states in the MCMC are handled in the <a class="el" href="classstateline_1_1mcmc_1_1_chain_array.html">ChainArray</a> class. A ChainArray holds the samples of all the chains that are used in the MCMC simulation. It gives each chain a unique ID to make it easier to iterate through chains and refer to specific chains. The IDs are given as follows:</p>
<div class="fragment"><div class="line">Stack 0    Stack 1    Stack 2</div>
<div class="line">-------    -------    -------</div>
<div class="line">   0          6          12          &lt;--- Coldest chain</div>
<div class="line">   1          7          13</div>
<div class="line">   2          8          14</div>
<div class="line">   3          9          15</div>
<div class="line">   4          10         16</div>
<div class="line">   5          11         17          &lt;--- Hottest chain</div>
</div><!-- fragment --><p>The term <em>stack</em> is used to refer to a sequence of chains with an increasing temperature ladder. Stacks are independent from each other, and are basically copies of each other, but exploring different parts of the search space (they do eventually have different temperatures and step sizes due to the adaption steps performed by the MCMC).</p>
<p>The most recent samples in the chain array are stored in memory for fast retrieval. However, as the number of samples get large, the chain array has to flush old samples to disk to make room for newer samples. Obsidian implements fault-tolerant persistence for its MCMC, so the simulation can be interrupted and recovered later (and can be resumed). Note that only the coldest chains are stored to disk.</p>
<p>Other tools in the Obsidian toolset such as <code>pickaxe</code> read from the database in order to extract MCMC samples. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Jun 30 2014 12:14:33 for Obsidian by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.7 </li>
  </ul>
</div>
</body>
</html>
